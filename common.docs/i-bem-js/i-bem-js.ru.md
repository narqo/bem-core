# i-bem.js: руководство пользователя

## i-bem.js: JavaScript-фреймворк для БЭМ

`i-bem.js` — специализированный JavaScript-фреймворк для веб-разработки
в рамках [БЭМ-методологии](https://ru.bem.info/method/).

`i-bem.js` позволяет:

 * разрабатывать веб-интерфейс в терминах блоков, элементов, модификаторов;
 * описывать логику работы блока в декларативном стиле — как набор состояний;
 * легко интегрировать JavaScript-код с BEMHTML- или BH-шаблонами и CSS в стиле БЭМ;
 * гибко переопределять поведение библиотечных блоков.

`i-bem.js` не предназначен:

 * для замены фреймворка общего назначения, подобного jQuery.

**Краткий обзор содержания документа**:

* [Общие сведения](#intro) о фреймворке: связь с понятиями предметной области БЭМ, краткое описание модульной структуры
фреймворка, шаблонного проекта и инструментов для сборки кода,
написанного с использованием `i-bem.js`.
* [Привязка JS-блоков к HTML](#html) — синтаксис указания JS-блоков на
HTML-странице, типы соотношения HTML-элементов и JS-блоков.
* [Декларация блока](#decl) — синтаксис описания JS-блоков.
* [Работа с DOM-деревом](#dom) — API для работы с DOM-узлами блоков:
элементы, динамическое изменение DOM-дерева (AJAX).
* [События](#events) — событийная модель `i-bem.js`: DOM-события,
БЭМ-события, делегирование событий.
* [Состояния блока](#states) — модификаторы, триггеры на смену
состояний (установку модификаторов), инициализация экземпляров
блоков.
* [Взаимодействие блоков](#ibc) — API для обращения из блока к другим блокам.
* [Что дальше?](#docs) — ссылки на документацию и дополнительные материалы.

<a name="intro"></a>
## Общие сведения

<a name="intro-bem"></a>
### БЭМ-методология и JavaScript

В БЭМ-методологии веб-интерфейс строится из независимых
**блоков** у которых могут быть **элементы**. И блоки,
и элементы могут иметь состояния или особенности, описываемые **модификаторами**.

Работа веб-интерфейса обеспечивается несколькими **технологиями**
(HTML, CSS, JS и т.д.). При использовании БЭМ-методологии вся реализация
веб-интерфейса разбита на компоненты по блокам. Описание блока в этой
схеме складывается из нескольких файлов — по одному на каждую технологию:

 * `my-block.css` — описывает внешний вид блока;
 * `my-block.bemhtml` — шаблоны для генерации HTML-представления блока;
 * `my-block.js` — описывает **динамическое поведение** блока в браузере.

Фреймворк `i-bem.js` позволяет разложить клиентский JavaScript на компоненты в терминах БЭМ:

* **Блок** — JS-компонент, описывающий логику работы однотипных элементов интерфейса. Например, все кнопки могут быть реализованы в виде блока `button`. В этом случае, в соответствии с БЭМ-методологией, `button.css` определяет внешний вид всех кнопок, а `button.js` — логику их работы.
На каждой странице может размещаться более одного **экземпляра блока** (например, кнопки). Каждому экземпляру блока соответствует JS-объект, динамически создаваемый в памяти браузера и хранящий состояние данного экземпляра. JS-объект хранит ссылку на DOM-узел, к которому привязан данный экземпляр блока.
* **Элементы** — DOM-узлы, вложенные в DOM-узел блока и имеющие атрибут `class`, указывающий на их роль в БЭМ-предметной области (имя блока и элемента). Элементы блока доступны через [JS-API](#elem-api) экземпляра блока.
* **Модификаторы** — хранят информацию о состоянии блока и его элементов. Состояние модификаторов записывается в атрибуте `class` на DOM-узлах блока и элементов. Управление модификаторами производится через [JS-API](#mods-api) экземпляра блока.

<a name="intro-build"></a>
### Сборка

Разработка в рамках БЭМ-методологии ведется модульно — каждый блок
программируется отдельно. Финальный исходный код веб-страниц
формируется из кода отдельных блоков с помощью процедур **сборки**.

В файловой системе блок удобно представлять в виде каталога, а реализацию блока в каждой из технологий — в виде отдельного файла:

```html
    desktop.blocks/
        my-block/
            my-block.css
            my-block.js
            my-block.bemhtml
            ...

    desktop.blocks/
        other-block/
            other-block.css
            other-block.js
            other-block.bemhtml
            ...
```


Для каждой веб-страницы код использованных на ней блоков может быть собран в единые файлы:

```html
    desktop.bundles/
        index/
            index.html
            index.css
            index.js
            ...
```


Для сборки кода результирующих веб-страниц из отдельных
описаний блоков существует два инструмента:

* [bem-tools](https://ru.bem.info/tools/bem/bem-tools/);
* [enb](https://github.com/enb-make/enb) совместно с [enb-modules](https://github.com/enb-make/enb-modules).

<a name="intro-name"></a>
### Почему i-bem.js так называется

В соответствии с БЭМ-методологией, базовая JS-библиотека БЭМ-платформы изначально разрабатывалась
как особый служебный блок. Такой подход позволяет работать с базовыми библиотеками так же, как
и с обычными блоками. В частности, структурировать код в терминах элементов и модификаторов и
гибко настраивать поведение библиотеки на разных уровнях переопределения.

Служебным блокам в БЭМ было принято давать имена с префиксом `i-`. Таким образом, имя `i-bem.js`
читается как *реализация блока `i-bem` в технологии `JS`*.

<a name="intro-use"></a>
### Как использовать i-bem.js

Фреймворк `i-bem.js` входит в состав библиотеки [bem-core](https://ru.bem.info/libs/bem-core/).

Реализация `i-bem.js` состоит из двух модулей:

* **Модуль [i-bem][]**.<br/>
Базовая реализация JS-блока `i-bem`, от которой наследуются все блоки в
`i-bem.js`. Блок `i-bem` написан с расчетом на использование в любом
JS-окружении: как на клиенте, так и на сервере например, в
Node.js).
* **Модуль [i-bem__dom][]**.<br/>
Базовая реализация блока, привязанного к DOM-узлу.
Рассчитан на использование на клиенте, опирается на работу браузеров с DOM. Зависит от `jQuery`.

Зависимости:

 * jQuery (только для модуля `i-bem__dom`). При использовании `bem-core` отдельная установка
 jQuery не требуется.
 * Модульная система [ym/modules][ym]. При использовании
   [bem-tools][] с технологией `.browser.js` (и производных от нее)
   эта зависимость удовлетворяется автоматически.

Можно использовать `i-bem.js` как часть полного стека
БЭМ-инструментов. В этом случае свой проект удобно создавать на основе
шаблонного репозитория [project-stub](https://github.com/bem/project-stub/), в котором настроена автоматическая установка зависимых библиотек и сборка.

Если не планируется использование других технологий БЭМ-платформы, достаточно поместить код библиотеки `bem-core` в существующий проект.

<a name="html"></a>
## Привязка JS-блоков к HTML

JavaScript-компоненты в `i-bem.js` служат для «оживления» HTML-элементов
страницы. Типовая задача JS-блока — установка реакции на события внутри HTML-фрагмента.

В `i-bem.js` первичным «каркасом» является HTML-дерево документа. В нем размечаются точки, к которым привязаны интерактивные элементы интерфейса — JS-блоки.
Точка привязки JS-блока — HTML-элемент (DOM-узел), в атрибуте `class` которого
указано имя блока, а в атрибуте `data-bem` — [параметры блока](#html-syntax).

При загрузке страницы в браузере выполняется [инициализация блоков](#init). В ходе нее создаются экземпляры блоков — JS-объекты всех блоков, упомянутых в классах HTML-элементов страницы. JS-объект, привязанный к HTML-элементу,
обрабатывает происходящие на нем [DOM-события](#dom-events) и хранит состояния данного экземпляра блока.

Такой способ привязки JavaScript-компонентов к HTML имеет следующие преимущества:

* естественная деградация интерфейса на клиентах с отключенным JavaScript;
* прогрессивный рендеринг — возможность начинать отрисовку элементов интерфейса до окончания загрузки всех данных страницы (например, изображений).

<a name="html-syntax"></a>
### Механизм привязки блоков

Чтобы привязать блок к HTML-элементу (например, `<div>...</div>`), необходимо:

* **Объявить блок в `js` технологии.**<br/>
Использовать в [декларации](#decl) имя блока в качестве первого аргумента `modules.define` и `BEMDOM.decl`.

```js
modules.define('my-block', ['i-bem__dom'], function(provide, BEMDOM){

provide(BEMDOM.decl(this.name,
    {
        /* методы экземпляра */
    },
    {
        /* статические методы */
    }
));

});
```


* **Отметить блок в HTML-дереве**.<br/>
Добавит HTML-элементу атрибут `class` с именем блока.

```html
 <div class="my-block">...</div>
```


* **Разрешить инициализацию экземпляра блока**.<br/>
Включить класс `i-bem` в список классов HTML-элемента. Наличие этого класса укажет фреймворку, что HTML-элемент связан с JS-блоком.

```html
<div class="my-block i-bem">...</div>
```
 

* **Передать параметры экземпляру блока**.<br/>
Поместить параметры блока в атрибут `data-bem`. Параметры блока записываются в формате JSON и представляют собой хэш вида: `имя блока : хэш параметров`. Параметры передаются экземпляру блока [в момент инициализации](#data-bem).

```html
<div class="my-block i-bem" data-bem='{ "my-block": { "name": "ya" } }'>...</div>
```


<a name="html-conection"></a>
### Связь блоков с HTML-элементами

Одному HTML-элементу не обязательно должен соответствовать один экземпляр блока. Возможны следующие типы связи между блоками и HTML-элементами:

* [Один HTML-элемент — один JS-блок](#html-simple).
* [Один HTML-элемент — несколько JS-блоков](#html-mixes).
* [Один JS-блок на нескольких HTML-элементах](#distrib-block).

<a name="html-simple"></a>
#### Один HTML-элемент — один JS-блок

Самый простой и распространенный способ привязки блоков к HTML.

**Пример:** HTML-элемент `div`, на котором размещен блок `my-block`.
Параметры блока: пустой список `{}`.

```html
<div class="my-block i-bem" data-bem='{ "my-block": {} }'>
    ...
</div>
```


<a name="html-mixes"></a>
#### Один HTML-элемент — несколько JS-блоков

Техника размещения нескольких блоков на одном HTML-элементе в БЭМ-методологии называется [микс](#inher-mixins).

**Пример:** HTML-элемент `div`, на котором размещены:

* блок `user` с параметром `name`: `pushkin`;
* блок `avatar` с параметром `img`: `http://...`.

```html
<div class="user avatar i-bem"
    data-bem='{
        "user": { "name": "pushkin" },
        "avatar": { "img": "http://..." }
     }'>
     ...
</div>
```


<a name="distrib-block"></a>
#### Один JS-блок на нескольких HTML-элементах

Такой дизайн удобен, если нужно согласовать состояния нескольких компонентов блока. 

Чтобы привязать экземпляр блока к нескольким HTML-элементам, в атрибуте `data-bem` всех привязываемых HTML-элементов нужно указать одинаковое значение параметра `id`.
Значением `id` может быть произвольная строка.

**Пример:** Экземпляр блока `notebook` привязан к HTML-элементам `div` и `span`.
В параметрах блока указан общий `id` — `maintab`.

```html
<div class="notebook i-bem" data-bem='{ "notebook": { "id": "maintab" }}'>
</div>
...
<span class="notebook i-bem" data-bem='{ "notebook": { "id": "maintab" }}'>
</span>
```


В результате при инициализации блоков создается один JS-объект, поле [`domElem`](#domElem) которого содержит ссылки на jQuery-объекты обоих DOM-узлов.

Например, виджет «вкладка», где клик по заголовку вкладки (первый HTML-элемент), меняет ее содержимое (второй HTML-элемент).
Другой пример: маркер, обозначающий точку на карте (первый элемент), и связанное с ним описание точки в списке рядом (второй элемент).

Идентификатор `id` используется *только в момент инициализации* экземпляра блока. Значение `id` должно быть уникальным для экземпляров одного блока, в рамках одной [волны инициализации](#init-wave).

<a name="i-blocks"></a>
### Блоки без DOM-представления

Инфраструктурный код, решающий общие задачи интерфейса (связь с бэкэндом, вспомогательные методы), можно оформить в виде блока. Это позволит выражать состояния блока с помощью [модификаторов](#modifiers) на изменение которых смогут [подписаться другие блоки](mods-api-trigger).

Чтобы не привязывать такие блоки к HTML-дереву искусственно в `i-bem.js` можно создавать блоки без DOM-представления.

Блоки без DOM-представления:

 * не требуют привязки к HTML-коду страницы;
 * должны быть явно [инициализированы](#init-bem) и уничтожены.

<a name="api-nodom"></a>
#### Доступ к экземплярам блоков без DOM-представления

При создании экземпляра блока без DOM-представления необходимо позаботиться о сохранении ссылки на этот экземпляр для блоков, которым нужно с ним взаимодействовать.

Смотрите также:
* [Инициализация и удаление блоков без DOM-представления](#init-bem).

<a name="data-bem"></a>
## Передача параметров экземпляру блока

### Синтаксис передачи параметров

Параметры блока хранятся в атрибуте `data-bem` HTML-элемента и передаются блоку в момент инициализации. Параметры позволяют влиять на поведение конкретного экземпляра блока, привязанного к данному HTML-элементу.

В значении атрибута `data-bem` указываются параметры *всех JS-блоков, размещенных на данном узле*. Значение атрибута `data-bem` должно содержать валидный JSON описвающий хэш вида:

* ключ — `{String}`, имя блока;
* значение — `{Object}`, параметры данного блока. Если данному экземпляру блока не требуются
параметры, указывается пустой хэш `{}`.

Указание имени блока в параметрах позволяет:

 * ускорить инициализацию блоков – не нужно парсить значение атрибута `class`.
 * размещать несколько блоков на одном HTML-элементе без необходимости множить его атрибуты.

### Доступ к параметрам из экземпляра блока

Доступ к параметрам из экземпляра блока можно получить через поле `this.params`. Его значение – хэш параметров из атрибута `data-bem` DOM-элемента блока (`this.domElem`).

```html
<div class="my-block i-bem" data-bem='{ "my-block": { "foo" : "bar" } }'></div>
```


```js
modules.define('my-block', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name, {
    onSetMod : {
        'js' : {
            'inited': function() {
                    console.log(this.params); // { foo : 'bar' }
            }
        }
    }
}));

});
```


Для получения **параметров элемента** служит метод экземпляра блока `elemParams`. Он принимает аргументом строку с именем элемента или его jQuery-объект. Возвращает хэш параметров элемента.

```html
<div class="my-block i-bem" data-bem='{ "my-block": {} }'>
    <div class="my-block__my-elem" data-bem='{ "my-block__my-elem": { "foo" : "bar" } }'></div>
</div>
```


```js
modules.define('my-block', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name, {
    onSetMod : {
        'js' : {
            'inited': function() {
                    console.log(this.elemParams('my-elem')); // { foo : 'bar' }
            }
        }
    }
}));

});
```


<a name="decl"></a>
## Декларация блока

JS-реализация блока описывает поведение определенного класса элементов веб-интерфейса. В конкретных интерфейсах каждый блок может быть представлен несколькими экземплярами. 
Экземпляр блока реализует функциональность своего класса и имеет собственное, независимое состояние.

В терминах парадигмы **объектно-ориентированного программирования**:

 * блок — класс;
 * экземпляр блока — экземпляр класса.

В соответствии с ООП, вся функциональность блока реализуется модульно в методах класса *(=блока)*.

Методы блока подразделяются на:

 * методы экземпляра блока;
 * статические методы.

Код блока в `i-bem.js` принято называть **декларацией**, чтобы подчеркнуть принятый
в БЭМ декларативный стиль программирования. 

Поведение блока программируется в декларативном стиле в виде утверждений: `набор условий` — `реакция блока`.

<a name="decl-syntax"></a>
### Синтаксис декларации

#### Блоки с DOM-представлением

##### Объявление нового блока без родителя

Чтобы задекларировать новый JS-блок **с DOM-представлением** (привязанный к HTML-элементу), нужно воспользоваться методом `decl` [ym][]-модуля `i-bem__dom`.

Метод `decl` принимает аргументы:

1. Описание блока `{String}` или `{Object}`.
2. Методы экземпляра блока — `{Object}`.
3. Статические методы — `{Object}`.

Объявленные методы будут применяться во всех экземплярах блока независимо от их состояний (модификаторов).

**Пример:** Декларация методов для блока `button`.

```js
modules.define('button', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name,
    {
        /* методы экземпляра */
    },
    {
        /* статические методы */
    })
);

});
```

Поле контекста `ym` `this.name`, передаваемое первым аргументом методу `BEMDOM.decl` содержит ссылку на имя блока, указанное первым аргументом `modules.define`.

<a name="bem-decl"></a>
#### Блоки без DOM-представления

Для декларации блоков без DOM-представления служит метод `decl` [ym][]-модуля `i-bem`.

Метод принимает те же параметры, что и метод `decl` модуля `i-bem__dom`:

```js
modules.define('my-block', ['i-bem'], function(provide, BEM) {

provide(BEM.decl(this.name,
    {
        /* методы экземпляра */
    },
    {
        /* статические методы */
    })
);

});
```


***

**NB** Оформлять инфраструктурный код в виде блока без DOM-представления удобно, если в нем планируется использовать API БЭМ-блоков (состояния, выражаемые модификаторами, БЭМ-события и
т. п.). Если использовать БЭМ-предметную область не планируется,
инфраструктурный код можно оформлять в виде [ym][]-модуля.

**Пример:**

```js
modules.define('router', function(provide) {

provide({
    route : function() { /* ... */ }
});

});
```


***

<a name="inher"></a>
### Наследование блока

Одна и та же функциональность может быть востребована в нескольких блоках проекта.
Например, разные блоки могут обращаться за данными к бэкенду, используя AJAX,
или совершать однотипные операции с DOM-деревом и т.д. Чтобы избежать ненужных повторов в коде, общую функциональность можно инкапсулировать в виде модулей, а затем добавлять к блокам.

Наследование позволяет повторно использовать функциональность блока, расширяя ее новой логикой.
В `i-bem.js` доступно несколько механизмов наследования. Выбор конкретного механизма зависит от специфики создаваемого блока.

<a name="inher-simple"></a>
#### Простое наследование

В случае простого наследования создаваемый блок объявляется как наследник существующего. Для этого нужно:

1. Указать базовый блок в зависимостях модульной системы.
2. Передать ссылку на базовый блок в специальном поле `baseBlock` декларации.

```js
modules.define('ablock', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name, {}));

});

modules.define('bblock', ['i-bem__dom', 'ablock'], function(provide, BEMDOM, ABlock) {

provide(BEMDOM.decl({ block : this.name, baseBlock : ABlock }));

});
```


Такой механизм позволяет использовать методы родительского блока внутри производного.
Для вызова базовой реализации одноименных методов родительского блока служит [специальное поле декларации](#decl-context) `this.__base`.

**NB** В `i-bem` можно создавать цепочки наследования – блок наследуется от другого,
который, в свою очередь, наследуется от третьего и т.д.

<a name="inher-over"></a>
#### Доопределение существующего блока

При наследовании можно сохранить основную функциональность базового блока.
Для этого можно **доопределить** базовый блок новым на уровне переопределения проекта.
Создаваемый в проекте блок реализует собственную логику, дополняющую или переопределяющую логику базового.
Такая схема наследования часто используется при работе с библиотечными блоками.

Чтобы доопределить существующий блок нужно создать новый блок с тем же именем.
Пересекающиеся методы и модификаторы будут переопределены в соответствие с декларацией нового блока.

```js
modules.define('ablock', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name, {})); // Объявляем базовый блок

});

modules.define('ablock', function(provide, ABlock) {

provide(ABlock.decl({})); // Доопределяем базовый блок

});
```


<a name="inher-over-modifier"></a>
##### Добавление модификатора к существующему блоку

В соответствии с БЭМ-методологией состояния блока должны описываться [модификаторами](#modifiers).
Поэтому расширение функциональности блока часто предполагает реализацию поддержки новых модификаторов.

Для добавления модификатора необходимо передать методу `decl` доопределяемого блока:

* хэш с ключами `modName` и `modVal`. Значением для `modName` служит строка – имя модификатора. Значением `modVal` – строка со значением модификатора.
* хэш методов, которые будут доступны для блока с соответствующим модификатором. Пересекающиеся методы будут переопределены методами из хэша.

```js
modules.define('ablock', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name, {})); // Объявляем базовый блок

});

modules.define('ablock', function(provide, ABlock) {

provide(ABlock.decl({ modName : 'm1', modVal : 'v1' }, {})); // Доопределяем базовый блок с модификтором _m1_v1

});
```


**NB** [Cтатические методы](#) блока будут доступны всем его экземплярам *вне зависимости от значений модификаторов*.
Модификаторы это свойства экземпляра блока, а статические методы принадлежат классу
блока и не учитывают состояния модификаторов.

<a name="inher-mixins"></a>
#### Блоки-миксы

В `i-bem.js` для добавления востребованной функциональности к блокам, используется специальный
тип блоков – **блоки-миксы**. Главная особенность блоков-миксов состоит в том, что они не участвуют в цепочке наследования. Это позволяет примешивать реализованную в них функциональность к другим блокам без риска нарушить их [связи с родительскими блоками](#context) (`this.__base`).

<a name="inher-mixins-declwithmix"></a>
##### Примешивание блока-микса

Чтобы примешать к блоку один или несколько блоков-миксов, необходимо в декларации блока присвоить значение опциональному полю `baseMix`. Значением служит массив строк – имен примешиваемых блоков-миксов:

```js
modules.define('my-block', ['i-bem__dom', 'foo', 'bar'], function(provide, BEMDOM) {

provide(BEMDOM.decl({ block : this.name, baseMix : ['foo', 'bar']},
    { /* методы экземпляра */ },
    { /* статические методы */ }
}));

});
```


<a name="inher-mixins-mixindecl"></a>
##### Декларация блока-микса

В качестве блоков-миксов можно использовать только блоки, созданные с помощью `declMix`.
Метод принимает декларацию блока в формате, аналогичном методу `decl`. 

Различие в том, что первым аргумент `declMix` – хэш вида `{ block : 'blockname' }`. Без указания модификаторов или примешиваемых блоков:

```js
modules.define('mymix', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.declMix({ block : 'mymix' },
    { /* методы экземпляра */ },
    { /* статические методы */ }
}));

});
```


<a name="trigger-decl"></a>
#### Декларация триггеров

Триггеры, выполняемые при установке модификаторов, описываются в декларации блока. Для этого в хэше методов экземпляра блока зарезервированы свойства:

* `beforeSetMod` — триггеры, вызываемые до установки
**модификаторов блока**;
* `beforeElemSetMod` — триггеры, вызываемые до установки
**модификаторов элементов**;
* `onSetMod` — триггеры, вызываемые после установки
**модификаторов блока**;
* `onElemSetMod` — триггеры, вызываемые после установки
**модификаторов элементов** блока.

```js
modules.define('block-name', function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name,
    {
        /* методы экземпляра */
        beforeSetMod: { /* триггеры до установки модификаторов блока*/}
        beforeElemSetMod: { /* триггеры до установки модификаторов элементов*/}
        onSetMod: { /* триггеры после установки модификаторов блока */ }
        onElemSetMod: { /* триггеры после установки модификаторов элементов */ }
    },
    {
        /* статические методы */
    }
));

});
```


Значение свойств `beforeSetMod` и `onSetMod` — хэш, связывающий изменения модификаторов с триггерами. Триггер получает аргументами:

* `modName` – имя модификатора;
* `modVal` – выставляемое значение модификатора;
* `prevModVal` – предыдущее значение модификатора. Для `beforeSetMod` это текущее значение модификатора, которое будет заменено на `modVal`, если триггер вернет `true`.

```js
{
    'mod1': function(modName, modVal, prevModVal) { /* ... */ }, // установка mod1 в любое значение
    'mod2': {
        'val1': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val1
        'val2': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val2
        '': function(modName, modVal, prevModVal) { /* ... */ } // триггер на удаление модификатора mod2
    'mod3': {
        'true': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку простого модификатора mod3
        '': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на удаление простого модификатора mod3
    },
    '*': function(modName, modVal, prevModVal) { /* ... */ } // триггер на установку любого модификатора в любое значение
}
```


Для триггера на установку любого модификатора блока в любое значение
существует сокращенная форма записи:

```js
beforeSetMod: function(modName, modVal, prevModVal) { /* ... */ }
onSetMod: function(modName, modVal, prevModVal) { /* ... */ }
```


Для свойств `beforeElemSetMod` и `onElemSetMod` в хэш значений
добавляется дополнительный уровень вложенности — **имя элемента**. В этих
свойствах описываются триггеры на установку модификаторов элементов.
Триггер получает аргументами:

* `elem` — имя элемента;
* `modName` – имя модификатора;
* `modVal` – выставляемое значение модификатора;
* `prevModVal` – предыдущее значение модификатора. Для `beforeSetMod` это текущее значение модификатора, которое будет заменено на `modVal`, если триггер вернет `true`.

```js
{
    'elem1': {
        'mod1': function(elem, modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod1 элемента elem 1 в любое значение
        'mod2': {
            'val1': function(elem, modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 элемента elem1 в значение val1
            'val2': function(elem, modName, modVal, prevModVal) { /* ... */ } // триггер на установку mod2 элемента elem1 в значение val2
            }
        },
    'elem2': function(elem, modName, modVal, prevModVal) { /* ... */ } // триггер на установку любого модификатора элемента elem2 в любое значение
}
```


Сокращенная запись для триггера на установку любого модификатора элемента `elem1` в любое значение:

```js
beforeElemSetMod: { 'elem1': function(elem, modName, modVal, prevModVal) { /* ... */ } }
onElemSetMod: { 'elem1': function(elem, modName, modVal, prevModVal) { /* ... */ } }
```


<a name="decl-context"></a>
### Специальные поля декларации

В декларации зарезервированы специальные поля:

* `this.__self`: предоставляет доступ к статическим методам блока из методов его экземпляра. Для статических методов не имеет смысла и не определено.

**Пример:** Вызов статического метода `staticMethod` в методе `onEvent` экземпляра блока `my-block`.

```js
BEMDOM.decl('my-block', {
    onEvent: function() {
        this.__self.staticMethod(); // вызов статического метода
        this.doMore();
    },
    {
        staticMethod: function() { /* ... */ }; // определение статического метода
    }
});
```


* `this.__base`: вызывает реализацию одноименного метода в базовом классе, от которого наследуется данный (`super call`). Определен в методах экземпляра и статических методах блока.

**Пример:** вызов базовой реализации метода `_onClick` базового класса `button`.

```js
BEMDOM.decl({ block: 'my-button', baseBlock: 'button' }, {
    _onClick: function() {
        this.__base();
        this.doMore();
    }
);
```


***

**NB** Так как блоки-миксы не участвуют в цепочке наследования, внутри них поле `__base` недоступно.

***

<a name="dom"></a>
## Работа с DOM-деревом

<a name="domElem"></a>
### DOM-узел экземпляра блока

Все экземпляры блоков с DOM-представлением, содержат в поле `this.domElem` jQuery-объект, ссылающийся на DOM-узлы, с которыми связан данный экземпляр.

<a name="elem-api"></a>
### Элементы

БЭМ-элементы блоков представлены в `i-bem.js` как DOM-узлы, вложенные в DOM-узел экземпляра блока. 

Для обращения к DOM-узлам элементов и работы с их модификаторами, следует использовать API экземпляра блока:

* Кэширующий доступ: `elem(elems, [modName], [modVal])`. Элемент,
полученный таким образом, не требуется сохранять в переменную.

```js
BEMDOM.decl('link', {
    setInnerText: function() {
        this.elem('inner').text('Текст ссылки');
        /* ... */
        this.elem('inner').text('Другой текст');
    }
);
```


* Некэширующий доступ: `findElem(elems, [modName], [modVal])`.

```js
BEMDOM.decl('link', {
    setInnerText: function() {
        var inner = this.findElem('inner');
        inner.text('Текст ссылки');
        /* ... */
        inner.text('Другой текст');
    }
});
```


При [динамическом добавлении и удалении элементов блока](#dynamic) может
потребоваться очистить кэш элементов. Для этого служит метод `dropElemCache('elements')`. Он принимает строку – разделенный пробелами список имен элементов, кэш которых нужно сбросить.

```js
BEMDOM.decl('attach', {
    clear: function() {
        BEMDOM.destruct(this.elem('control'));
        BEMDOM.destruct(this.elem('file'));
        return this.dropElemCache('control file');
    }
});
```


Полное описание API для работы с элементами содержится в исходном коде модуля [i-bem__dom][].

<a name="api-find"></a>
### Поиск экземпляров блоков в DOM-дереве

Обращение к другому блоку в `i-bem.js` выполняется из текущего блока,
размещенного на определенном узле DOM-дерева. Поиск других блоков в
DOM-дереве может вестись по трем направлениям (осям) относительно
DOM-узла текущего блока:

* **Внутри блока** — на DOM-узлах, вложенных в DOM-узел текущего блока. Вспомогательные методы: `findBlocksInside([elem], block)` и `findBlockInside([elem], block)`.
* **Снаружи блока** — на DOM-узлах, потомком которых является DOM-узел
текущего блока. Необходимость в таком поиске может свидетельствовать
о неудачной архитектуре интерфейса. Вспомогательные методы: `findBlocksOutside([elem], block)` и `findBlockOutside([elem], block)`.
* **На себе** — на том же DOM-узле, на котором размещен текущий блок. Это актуально в случае [размещения нескольких JS-блоков на одном DOM-узле](#html-mixes) (микс). Вспомогательные методы: `findBlocksOn([elem], block)` и `findBlockOn([elem], block)`.

Сигнатура вспомогательных методов идентична:

* `[elem]` `{String|jQuery}` – имя или DOM-узел элемента блока.
* `block` `{String|Object}` – имя или описание искомого блока. Описанием служит хеш вида `{ block : 'name', modName : 'foo', modVal : 'bar' }`.

Вспомогательные методы для поиска парные. Различаются возвращаемым значением:

* `findBlocks<Direction>` – возвращает массив найденных блоков.
* `findBlock<Direction>` – возвращает первый найденный блок.

**Пример**: При переключении модификатора `disabled` экземпляр блока
`attach` находит вложенный в него блок `button` и переключает его
модификатор `disabled` в то же значение, которое получил сам:

```js
modules.define('attach', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name, {
    onSetMod: {
        'disabled': function(modName, modVal) {
            this.findBlockInside('button').setMod(modName, modVal);
        }
    }
}));

});
```


**NB** Не используйте jQuery-селекторы для поиска блоков и элементов.
`i-bem.js` предоставляет высокоуровневое API для доступа к DOM-узлам блоков и элементов. Прямое обращение к DOM-дереву делает код менее устойчивым к изменениям БЭМ-библиотек и может привести к возникновению сложно обнаруживаемых ошибок.

<a name="dynamic"></a>
### Динамическое обновление блоков и элементов в DOM-дереве

В современных интерфейсах зачастую необходимо создавать новые
фрагменты DOM-дерева и заменять старые в процессе работы (AJAX). В
`i-bem.js` предусмотрены следующие функции для добавления и замены
фрагментов DOM-дерева.

* Добавить DOM-фрагмент:

  * `append` —  в конец указанного контекста;
  * `prepend` — в начало указанного контекста;
  * `before` — перед указанным контекстом;
  * `after` — после указанного контекста;

* Заместить DOM-фрагмент:

  * `update` —  внутри указанного контекста;
  * `replace` — заменить указанный контекст новым DOM-фрагментом.

Все функции автоматически выполняют [инициализацию блоков на обновленном фрагменте DOM-дерева](#init-ajax).

Чтобы упростить создание БЭМ-сущностей на обновляемых фрагментах
DOM-дерева, можно использовать шаблонизатор
[BEMHTML](https://ru.bem.info/technology/bemhtml/current/intro/), подключив
его в качестве [ym][]-модуля. БЭМ-сущности описываются в формате
[BEMJSON](https://ru.bem.info/technology/bemjson/current/bemjson/)
непосредственно в коде блока. Функция `BEMHTML.apply` генерирует
HTML-элементы по BEMJSON-декларации в соответствии с правилами
именования БЭМ.

**Пример:** Метод `_updateFileElem` блока `attach` удаляет элемент `file`, если он существовал, и создает новый элемента с помощью функции `BEMHTML.apply`:

```js
modules.define(
    'attach',
    ['BEMHTML', 'strings__escape', 'i-bem__dom'],
    function(provide, BEMHTML, escape, BEMDOM) {

provide(BEMDOM.decl(this.name, {
    _updateFileElem : function() {
        var fileName = extractFileNameFromPath(this.getVal());
        this.elem('file').length && BEMDOM.destruct(this.elem('file'));
        BEMDOM.append(
            this.domElem,
            BEMHTML.apply({
                block : 'attach',
                elem : 'file',
                content : [
                    {
                        elem : 'icon',
                        mods : { file : extractExtensionFromFileName(fileName) }
                    },
                    { elem : 'text', content : escape.html(fileName) },
                    { elem : 'clear' }
                ]
            }));
        return this.dropElemCache('file');
    }
}));

});
```


<a name="context"></a>
## Контекст

**Методы экземпляра блока** исполняются в контексте JS-объекта экземпляра блока. Ключевое слово `this` в методах экземпляра блока ссылается на JS-объект **экземпляра блока**.

**Статические методы** исполняются в контексте JS-объекта, соответствующего классу блока. Ключевое слово `this` в статических методах блока ссылается на **класс блока**.

***

**NB** При разработке блоков с использованием `i-bem.js` внутренним методам блока, не предназначенным для использования извне, принято давать имена, начинающиеся с символа подчеркивания. Например, `_onClick`.

***

Набор свойств, доступных в контексте блока разнится для блоков с DOM и без DOM-представления.

### Свойства экземпляра блока

#### DOM

* `params` – хэш параметров, переданных экземпляру блока при инициализации.

#### BEMDOM

* `params` – хэш параметров, переданных экземпляру блока при инициализации.
* `domElem` – ссылка на DOM-элементы к которым привязан блок.

### Статические свойства блока

#### DOM

* `blocks` – хранилище деклараций блоков. Содержит хэш, ключами которого являются имена блоков. Служит для получения доступа к классам блоков.

#### BEMDOM

* `blocks` – хранилище деклараций блоков. Содержит хэш, ключами которого являются имена блоков. Служит для получения доступа к классам блоков.
* `scope` – корневой элемент обрабатываемого DOM-дерева. Позволяет выполнять несколько разных версий `i-bem.js` в одном рантайме. По умолчанию содержит ссылку на jQuery объект `body`.
* `doc` – ссылка на jQuery объект `document`.
* `win` – ссылка на jQuery объект `window`.

<a name="states"></a>
## Состояния блока

Проектируя динамический блок в стиле БЭМ, нужно представить всю логику
изменений, происходящих в нем, как набор **состояний** блока. Тогда
поведение блока определяется **триггерами** — callback-функциями, которые
выполняются при переходе блока из одного состояния в другое.

Это позволяет писать код блока в декларативном стиле как набор утверждений вида: `описание состояния` — `действия, выполняемые при переходе в данное состояние`.

<a name="modifiers"></a>
### Модификаторы

Согласно БЭМ-методологии, состояние блока и его элементов описывается
**модификаторами**.

Модификатор указывает, в каком из возможных состояний находится блок. Модификатор представляет собой пару: **имя** и **значение**. Список допустимых значений модификатора описывает набор состояний блока. Например, для описания размеров блока
можно использовать модификатор `size` с допустимыми значениями `s`, `m` и
`l`.

**Простой модификатор** — частный случай, когда важно только наличие
или отсутствие модификатора у блока, а его значение несущественно. Например, модификатор описывающий состояние «отключен»: `disabled`. В `i-bem.js` представлены как модификаторы с булевым значением. При выставлении модификатора с неуказанным значением
`i-bem.js` автоматически присваивает ему значение `true`.

Каждому блоку можно установить один или несколько модификаторов. Блок
может не иметь модификаторов. Список допустимых модификаторов и их
значений определяет разработчик блока.

В `i-bem.js` модификаторы устанавливаются при
[инициализации экземпляра блока](#init) (если модификаторы и их
значения указаны в атрибуте `class` соответствующего HTML-элемента).

**NB** Если модификаторы блока указаны в HTML-элементе, при
инициализации блока триггеры на установку данных модификаторов *не
выполняются*. Экземпляр блока в этом случае получает начальное
состояние, а не меняет его.

Модификаторы могут добавляться, удаляться и менять значения:

* в ходе выполнения кода блока (например, как реакция на [DOM-события](#dom-events));
* по запросу из другого блока (см. раздел [Взаимодействие блоков](#ibc)).

При добавлении, удалении и изменении значений модификаторов выполняются [триггеры](#mods-api-trigger).

<a name="mods-api"></a>
#### Управление модификаторами

Экземпляр блока предоставляет методы для установки, удаления и проверки значений его модификаторов.

**NB** Для изменения значений модификаторов используйте описанный ниже API экземпляра блока. Не следует устанавливать модификаторы, самостоятельно изменяя CSS-классы соответствующего DOM-узла.

Доступен следующий набор методов для управления модификаторами:

* `hasMod([elem], modName, [modVal])` – проверяет наличие модификатора. Возвращает `true` если модификатор `modName` установлен.
* `getMod([elem], modName)` – возвращает строку со значеним модификатор `modName`.
* `getMods([elem], [...modNames])` – возвращает хэш со значениями всех модификаторов блока и его элементов. Можно ограничить действие метода указав нужный элемент `[elem]` или `[...modNames]` – строку с именами модификаторов разделенными пробелом.
* `setMod([elem], modName, [modVal=true])` – устанавливает блоку (элементу) модификатор `modName`. Если не указана строка со значением `[modVal=true]` будет установлен *простой модификатор*.
* `toggleMod([elem], modName, modVal1, [modVal2], [condition])` – переключает значения модификатора. Если аргумент `[modVal2]` передан, то между `modVal1` и `[modVal2]`, если нет будет поочередно устанавливаться и удаляться `modVal1`.
* `delMod([elem], modName)` – удаляет у блока модификатор `modName`.

**Пример:** Экземпляр блока `square` может по клику на DOM-элементе блока переключаться между значениями `green` и `red` модификатора `color`, если не выставлен модификатор `disabled`:

```js
BEMDOM.decl('square', {
    onSquareClick: function(e) {
        if(!this.hasMod('disabled')) {
            this.toggleMod('color', 'green', 'red');
        }
    }
});
```


Эти же методы позволяют управлять модификаторами элементов блока. Для этого первым аргументом передается ссылка на **DOM-узел элемента** (а не имя элемента).

Иначе возникла бы неоднозначность: имеется в виду установка блоку *модификатора* `input` со значением `clean` или установка элементу `input` *простого модификатора* `clean`.

**Пример:** Блок `searchbox` по клику может выставлять своему элементу `input` простой модификатор `clean` (подразумеваемое значение — `true`):

```js
BEMDOM.decl('searchbox', {
    _onClick: function() {
        this.setMod(this.elem('input'), 'clean');
    }
});
```


Полное описание API для управления модификаторами приведено в
исходном коде модулей [i-bem][] и [i-bem__dom][].

<a name="mods-api-trigger"></a>
### Триггеры на установку модификаторов

Выполнение триггеров на установку модификаторов разбито на две фазы:

1. **До установки модификатора**. Эта фаза зарезервирована для
возможности **отменить** установку модификатора. Если хотя бы один
из триггеров, выполняемых в этой фазе, вернет `false`,
установки модификатора не произойдет.
2. **После установки модификатора**. Триггеры, выполняемые в этой
фазе, уже не могут отменить установку модификаторов.

Триггеры могут быть привязаны к следующим типам изменений значений модификаторов:

1. установка *любого* модификатора в *любое* значение;
2. установка *конкретного* модификатора `modName` в *любое* значение (в том числе
установка простого модификатора в значение `true`);
3. установка *конкретного* модификатора `modName` в *конкретное* значение `modVal`;
4. установка модификатора в значение `''` (пустая строка), что
эквивалентно удалению модификатора или установке простого
модификатора в значение `false`.

При установке модификатора `modName` в значение `modVal` триггеры
каждой фазы (если они определены) вызываются в том порядке, в котором они
перечислены в приведенном выше списке событий (от общего к частному).

Таким образом, при определении триггера пользователь указывает:

* фазу выполнения (до или после установки модификатора);
* тип события (имя и устанавливаемое значение модификатора).

<a name="mods-api-trigger-phase"></a>
#### Фазы выполнения

Дополнительная фазы, предшествующая установке модификатора, позволяет
произвести некоторые проверки без риска повлиять на логику, связанную с установкой модификатора. Например, если существуют взаимоисключающие модификаторы, перед установкой одного из них логично проверить не установлен ли другой.

В блоке `checkbox-group` библиотеки `bem-components` перед установкой модификатора `focused` производится проверка на наличие модификатора `disabled`:

```js
provide(BEMDOM.decl(this.name, {
    beforeSetMod : {
        'focused' : {
            'true' : function() {
                return !this.hasMod('disabled');
            }
        }
    },

    onSetMod : {
        'focused' : { /* ... */}
    }
}));
```


Если триггер для фазы, предшествующей установке (`beforeSetMod`), возвращает `false`, установка модификатора не производится.

Подробнее об использовании триггеров читайте в разделе [Декларация триггеров](#trigger-decl)

#### Примеры триггеров

Типовая задача триггеров, вызываемых после установки модификатора или
изменения его значения (свойство `onSetMod`) — выполнить операции над
DOM-узлом блока, необходимые для перехода в новое состояние.

**Пример:** Экземпляр блока `input` при установке простого
модификатора `focused` (в значение `true`) очищает поле ввода —
заменяет пустой строкой текст DOM-узла блока.

```js
BEMDOM.decl('input', {
    onSetMod : {
        'focused' : {
            'true' : function() {
                this.domElem.val(''); // очистить поле ввода
            }
        }
    }
});
```


Триггеры, выполняемые перед установкой модификатора (свойство `beforeSetMod`), служат для проверки текущего состояния экземпляра блока и возможности отменить переход в другое состояние.

**Пример:** Экземпляр блока `input` перед установкой простого
модификатора `focused` проверяет, не выставлен ли у него модификатор
`disabled`. Если `disabled` выставлен, будет возвращено значение `false` и
установки модификатора `focused` не произойдет.

```js
BEMDOM.decl('input', {
    beforeSetMod : {
        'focused' : {
            'true' : function() {
                return !this.hasMod('disabled'); // вернет false, если disabled
            }
        }
    }
});
```


<a name="events"></a>
## События

В `i-bem.js` поддерживается два вида событий:

* **DOM-событие** — jQuery-событие на DOM-узле, связанном с
блоком. Отражает взаимодействие пользователя с интерфейсом (клик,
наведение мыши, ввод текста и т.п.). DOM-событие обычно обрабатывает
тот экземпляр блока, на DOM-узле которого оно возникло.
* **БЭМ-событие** — собственное событие, генерируемое
блоком. Позволяет организовать API для
[взаимодействия с блоком](#ibc). БЭМ-событие обычно обрабатывает
экземпляр блока, отслеживающий состояние других блоков, на которых
генерируются события.

DOM-события следует использовать только во *внутренних* процедурах блока. Для
взаимодействия блока с *внешней* средой (другими блоками), предназначены БЭМ-события.

<a name="delegated-events"></a>
### Делегирование событий

Обработка БЭМ- и DOM-событий может быть **делегирована** контейнеру
(всему документу или конкретному DOM-узлу). В этом случае контейнер
служит точкой обработки событий, возникающих на любом из его
дочерних узлов, даже если в момент подписки на события
некоторых из дочерних узлов еще не существовало.

Блок меню может содержать вложенные блоки (или элементы, в
зависимости от конкретной реализации блока): например, пункты меню. Обработку
кликов на пунктах меню имеет смысл делегировать самому блоку
меню. Это, во-первых, позволяет сэкономить затраты ресурсов на
подписку на события (дешевле подписаться на одно событие контейнера,
чем на много событий элементов). Во-вторых, дает возможность добавлять и удалять пункты меню, не подписываясь на события добавленных пунктов и не отписываясь от событий удаленных.

Возможно делегировать как БЭМ, так и DOM-события.

<a name="dom-events"></a>
### DOM-события

Работа с DOM-событиями в `i-bem.js` полностью реализована средствами фреймворка jQuery.

#### Подписка на DOM-событие

У объекта экземпляра блока зарезервирован набор методов для подписки на DOM-события:

* `bindToDomElem(domElem, event, [data], fn)` – на события произвольного DOM-узла `domElem`.
* `bindToDoc(event, [data], fn)` – на события DOM-узла `document`.
* `bindToWin(event, [data], fn)` – на события DOM-узла `window`.
* `bindTo([elem], event, handler)` — на события основного DOM-узла блока и DOM-узлов его элементов.

**Пример:** В момент [инициализации экземпляра блока](#init)
`my-block` выполняется подписка на событие `click`, при наступлении
которого блок выставляет себе [модификатор](#modifier) `size` в
значение `big`.

```js
BEMDOM.decl('my-block', {
    onSetMod : {
        'js' : {
            'inited': function() {
                this.bindTo('click', function(e) {
                    var domElem = $(e.currentTarget); // DOM-элемент, на котором слушается событие
                                                      // в данном случае то же, что this.domElem
                    this.setMod('size', 'big');
                });
            }
        }
    }
});
```


**Пример:** При [инициализации экземпляра блока](#init) `my-form` выполняется
подписка на событие `click` элемента `submit`, при наступлении
которого будет вызван метод экземпляра блока `_onSubmit`.

```js
BEMDOM.decl('my-block', {
    onSetMod : {
        'js' : {
            'inited': function() {
                this.bindTo('submit', 'click', function(e) {
                    var domElem = $(e.currentTarget); // DOM-элемент, на котором слушается событие
                                                      // в данном случае то же, что this.elem('submit')
                    this._onSubmit();
                });
            }
        }
    },

    _onSubmit : function() { /* ... */ }
});
```


**NB** Функция-обработчик выполняется в контексте того экземпляра
блока, в котором возникло событие.

#### Удаление подписки на DOM-событие

Удаление подписки на DOM-события выполняется автоматически при уничтожении экземпляра блока. Тем не менее, у объекта экземпляра блока зарезервирован набор методов для удаления подписки вручную во время работы блока:

* `unbindFromDomElem(domElem, event, [fn])` – от событий произвольного DOM-узла `domElem`.
* `unbindFromDoc(event, [fn])` – от событий DOM-узла `document`.
* `unbindFromWin(event, [fn])` – от событий DOM-узла `window`.
* `unbindFrom([elem], event, [handler])` — от событий основного DOM-узла блока и DOM-узлов его элементов.

Если при вызове одного из методов не указана функция-обработчик, будут удалены все обработчики, установленные на DOM-узле для этого события.

```js
_stopKeysListening : function() { 
    this.unbindFromDoc('keydown'); // удаляем все обработчики события 'keydown' у DOM-узла document
} 
```


#### Объект DOM-события
Первым аргументом функция-обработчик получает jQuery-объект DOM-события — [`{jQuery.Event}`](https://api.jquery.com/category/events/event-object/).

Это позволяет использовать методы объекта такие, как `stopPropogation` и `preventDefault`, для управления распространением события и его обработкой браузером.

```js
BEMDOM.decl('my-block', {
    onSetMod : {
        'js' : {
            'inited': function() {
                this.bindTo('click', function(e) {
                    e.stopPropogation(); // останавливаем всплытие события
                    this._onSubmit();
                });
            }
        }
    },

    _onSubmit : function() {
    /* ... */
    }
});
```


Вместо вызова `stopPropogation()` можно вернуть `false` из функции-обработчика.

```js
this.bindTo('click', function(e) {
    this._onSubmit();
    return false
});
```


Если DOM-событие было сгенерировано вручную, все параметры, переданные функции `trigger` при создании события, будут переданы функции-обработчику в том же порядке после объекта события.

**N.B.** Параметры окружения и поведение функции-обработчика события идентичны [функции-обработчику](http://api.jquery.com/on/#event-handler) jQuery.

<a name="dom-events-delegated"></a>
#### Делегирование DOM-событий

Делегировать обработку DOM-событий рекомендуется с помощью метода `liveBindTo([elem], event, handler)`. В статических методах декларации блока зарезервированно свойство `live` для подписки на делегированные DOM-события.

**Пример:** Все экземпляры блока `menu` подписываются на делегированное DOM-событие `click` своих элементов `item`. Метод `_onItemClick` экземпляра блока `menu` будет выполняться при клике на любой элемент `item` в меню. Не важно, существовал ли этот элемент в момент инициализации экземпляра.

```js
BEMDOM.decl('menu', {
    _onItemClick : function(e) {
        var clickedItem = $(e.target).closest(this.buildSelector('item')); // элемент 'item' блока 'menu', на котором слушается DOM-событие 'click'
    }
}, {
    live : function() {
        this.liveBindTo('item', 'click', function(e) {
            this._onItemClick(e);
        });
    }
});
```


Если в декларации блока задано свойство `live`, инициализация экземпляров блока будет *отложена* до момента, когда экземпляр блока потребуется в работе ([ленивая инициализация](#init-live)). Таким моментом может стать DOM-событие на экземпляре блока, на которое выполнена делегированная подписка, или обращение к экземпляру блока [из другого блока](#ibc).

**NB** Функция-обработчик выполняется в контексте ближайшего блока данного типа на пути всплывания DOM-события (снизу вверх по DOM-дереву).

Чтобы воспользоваться делегированными событиями в блоке не откладывая инициализацию (экземпляры блока должны быть инициализированы по `domReady`), следует вернуть `false`:

```js
modules.define('my-block', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name,
    {
        onSetMod: {
            'js': {
                'inited': function() { /* ... */ } // будет выполнена по наступлении domReady
            }
        },

        _onClick: function() { /* ... */ } // будет выполняться каждый
                                           // раз при наступлении DOM-события 'click'
    },
    {
        live: function() {
            this.liveBindTo('click', function() { this._onClick() });
            return false; // экземпляры блоков будут инициализированы автоматически
        }
    }
));

});
```


**Удаление подписки** на делегированные DOM-события никогда не выполняется автоматически. Для ее удаления используйте метод `liveUnbindFrom([elem], event, [handler])`.

```js
BEMDOM.decl('menu', {
    onSetMod : {
        'js' : {
            '' : function() {
                this.liveUnbindFrom('item', 'click', function(e) { this._onItemClick(e) });
            }
        }
    }
});
```


<a name="bem-events"></a>
### БЭМ-события

В отличие от DOM-событий, БЭМ-события генерируются не на DOM-элементах, а на **экземплярах блоков**. Элементы блоков не могут генерировать БЭМ-события.

<a name="bem-events-subscribe"></a>
#### Генерация БЭМ-события

Чтобы сгенерировать БЭМ-событие, используется метод экземпляра блока
`emit(event, [data])`.

Взаимодействие пользователя с элементом управления блока (DOM-событие) можно преобразовать в БЭМ-событие на блоке. Например, при клике по кнопке `submit` (DOM-событие `click`) **БЭМ-событие** `click` генерируется только в том случае, если у блока в этот момент не выставлен модификатор `disabled`:

```js
BEMDOM.decl('submit', {
    onSetMod: {
        'js': {
            'inited': function() {
                this.bindTo('click', this._onClick); // подписка на DOM-событие "click"
            }
        }
    },

    _onClick: function() {
        if(!this.hasMod('disabled')) {
            this.emit('click'); // создание БЭМ-события "click"
        }
    }
});
```


Вторым аргументом методу можно передать произвольные данные, которые будут доступны как второй аргумент функции-обработчика.

<a name="bem-events-subscribe"></a>
#### Подписка на БЭМ-события

Для подписки на БЭМ-события экземпляров блоков используются методы
экземпляра блока `on(event, [data], handler, [handlerCtx])`.

**Пример:** В момент инициализации HTML-формы (экземпляра блока `my-form`) выполняется поиск вложенной в форму кнопки `submit` и подписка на ее БЭМ-событие `click`. В результате при нажатии на кнопку (экземпляр блока `submit`) будет выполнен метод `_onSubmit` формы (экземпляр блока `my-form`).

```js
BEMDOM.decl('my-form', {
    onSetMod: {
        'js': {
            'inited': function() {
                this.findBlockInside('submit').on(
                    'click', // имя БЭМ-события
                    this._onSubmit, // метод экземпляра блока my-form
                    this); // контекст для выполнения _onSubmit — блок my-form
            }
        }
    },

    _onSubmit: function() { /* ... */ }
});
```


**NB** Если не указывать последний параметр метода `on` —
`[handlerCtx]`, контекстом для выполнения функции-обработчика будет
тот блок, в котором возникло БЭМ-событие (в примере выше это блок
`submit`).

<a name="bem-events-unsubscribe"></a>
#### Удаление подписки на БЭМ-события

Удаление подписки на БЭМ-события выполняется автоматически при уничтожении экземпляра блока. Для ручного удаления подписки, используйте метод экземпляра блока
`un(event, [handler], [handlerCtx])`.

<a name="bem-events-modchange"></a>
#### События при изменении модификаторов

Для подписки на БЭМ-события при изменении модификатора блока или элемента используется метод экземпляра блока `on`. Метод принимает аргументами:

* объект, описывающий модификатор, на который производится подписка;
* функцию обратного вызова, выполняющуюся при установке соответствующего модификатора.

Объект, описывающий модификатор, может содержать следующие зарезервированные свойства:

* `modName` `{String}` – имя модификатора. Обязательное свойство.
* `modVal` `{String}` – значение модификатора. Обязательное свойство. Со значением `*` производится подписка на установку модификатора в **любое** значение. Со значением `''` – на **удаление** модификатора. Подробнее смотрите в разделе [триггеры на установку модификаторов](#mods-api-trigger).
* `elem` `{String}` – имя элемента (для модификаторов элементов).

**Пример:** В момент инициализации блока `monitor` выполнятся подписка на:

* установку модификатора `m1` в любое значение;
```js
BEMDOM.decl('monitor', {
    onSetMod: {
        'js': {
            'inited': function() {
              block1.on({ modName : 'm1', modVal : '*' }, function() {});
            }
        }
    },
});
```


* установку модификатора `m1` в значение `v1`;
```js
block1.on({ modName : 'm1', modVal : 'v1' }, function() {});
```


* удаление модификатора `m1`;
```js
block1.on({ modName : 'm1', modVal : '' }, function() {});
```


* удаление модификатора `m1` у элемента `e1`;
```js
block1.on({ elem : 'e1', modName : 'm1', modVal : '' }, function() {});
```


**NB** В целях оптимизации производительности БЭМ-события при изменении модификаторов генерируются только, если для них есть подписчики.


<a name="bem-events-delegated"></a>
#### Делегирование БЭМ-событий

Делегирование БЭМ-событий означает, что блок подписывается на определенное БЭМ-событие **всех экземпляров** блока с заданным именем **в пределах заданного контекста**. Подписка на делегированные БЭМ-события выполняется с помощью статического метода `BEMDOM.on([ctx], event, [data], handler, [handlerCtx])`.

Параметры:

* `{jQuery} [ctx]` — DOM-узел, в пределах которого отслеживаются БЭМ-события (контейнер). Если не указан, в качестве контейнера используется весь документ.
* `{String} event` — имя БЭМ-события.
* `{Object} [data]` — произвольные данные, передаваемые функции-обработчику.
* `{Function} handler` — функция-обработчик события.
* `{Object} [handlerCtx]` — контекст функции-обработчика события. Если отсутствует, функция-обработчик будет выполняться в контексте экземпляра блока в котором произошло событие.

**Пример:** При инициализации экземпляров блока `menu` выполняется подписка на БЭМ-событие `click` всех ссылок (экземпляров блока `link`) в пределах DOM-узла блока (`this.domElem`). В качестве контекста функции-обработчика передается текущий экземпляр блока.
При [уничтожении экземпляров блока](#destruct) `menu` с помощью статического метода `un([ctx], event, [handler], [handlerCtx])` производится **удаление подписки** на делегированные
БЭМ-события.

```js
BEMDOM.decl('menu', {
    onSetMod : {
        'js' : {
            'inited' : function() {
                BEMDOM.blocks['link'].on( // подписка на БЭМ-событие
                    this.domElem, // контейнер — DOM-узел экземпляра блока menu
                    'click', // БЭМ-событие
                    this._onLinkClick, // обработчик
                    this); // контекст обработчика — экземпляр блока menu
            },

            '' : function() {
                BEMDOM.blocks['link'].un( // удаление подписки на БЭМ-событие
                    this.domElem,
                    'click',
                    this._onLinkClick,
                    this);
            }
        }
    },

    _onLinkClick : function(e) {
        var clickedLink = e.target; // экземпляр блока 'link', на котором произошло БЭМ-событие 'click'
    }
});
```


Делегировать можно любые БЭМ-событий, в том числе и события при изменении модификаторов.

**NB** **Удаление подписки** на делегированные БЭМ-события никогда не происходит автоматически. Всегда следует явно удалять подписку при
помощи статического метода блока `un([ctx], event, [handler], [handlerCtx])`.

<a name="api"></a>
### Объект БЭМ-события

В качестве параметра функции-обработчику передается объект, описывающий БЭМ-событие. Класс объекта БЭМ-события `events.Event` определен в [ym][]-модуле [`events`](https://github.com/bem/bem-core/blob/v2/common.blocks/events/events.vanilla.js) библиотеки bem-core. Содержит поля:

* `target` — экземпляр блока, в котором произошло БЭМ-событие.
* `data` — произвольные дополнительные данные, переданные как аргумент `data` при подписке на БЭМ-событие.
* `result` — последнее значение, возвращенное обработчиком данного события. Аналогично [jQuery.Event.result](https://api.jquery.com/event.result/).
* `type` — тип события. Аналогично [jQuery.Event.type](https://api.jquery.com/event.type/).

Подробнее о свойствах и методах объекта БЭМ-события читайте в [документации блока event](https://github.com/bem/bem-core/blob/v2/common.blocks/events/events.ru.md).

<a name="init"></a>
## Инициализация

Инициализация блока — это создание в памяти браузера JS-объекта,
соответствующего экземпляру блока. Инициализация экземпляров блоков выполняется
методом `init()` модуля `i-bem__dom` на заданном фрагменте DOM-дерева.

Каждому экземпляру блока можно приписать три состояния:

* экземпляр блока не инициализирован (JS-объект не создан);
* экземпляр блока инициализирован (JS-объект создан в памяти браузера);
* экземпляр блока уничтожен (удалены все ссылки на JS-объект экземпляра
блока, и он может быть удален сборщиком мусора).

В `i-bem.js` эти состояния экземпляра блока описываются с помощью служебного
модификатора `js`.

* До инициализации экземпляр блока не имеет модификатора `js`.

```html
<div class="my-block i-bem" data-bem="..." >...</div>
```


* В момент инициализации экземпляру блока устанавливается модификатор
`js` в значении `inited`.

```html
<div class="my-block i-bem my-block_js_inited" data-bem="...">...</div>
```


* Если в процессе работы удаляется фрагмент DOM-дерева (при помощи метода `destruct` модуля `i-bem__dom`), то вместе с ним удаляются экземпляры блоков, все HTML-элементы которых находятся в этом фрагменте. Перед удалением экземпляра блока модификатор `js` удаляется, чтобы выполнились [деструкторы экземпляра](#destruct) блока.

**NB** Если экземпляр блока был [привязан к нескольким HTML-элементам](#distrib-block), блок будет существовать, пока в HTML-дереве сохраняется хотя бы один элемент, с которым он
связан.

Если на HTML-элементе размещено несколько экземпляров других блоков, то
инициализация одного из них (появление модификатора `my-block_js_inited`)
не влияет на инициализацию остальных.

**Пример:** На HTML-элементе инициализирован только экземпляр блока `my-block`.
Экземпляр блока `lazy-block` не инициализирован:

```html
<div class="my-block my-block_js_inited lazy-block i-bem"
    data-bem='{ "my-block": {}, "lazy-block": {} }' >
    ...
</div>
```


**NB** Наличие модификатора `js` позволяет писать разные CSS-стили для
блока в зависимости от того, инициализирован он или нет.

### Конструктор экземпляра блока

На изменение значений модификатора `js` можно назначать триггеры так
же, как и для любых других модификаторов блока.

Триггер на установку модификатора `js` в значение `inited` выполняется
при создании блока. Этот триггер можно считать **конструктором
экземпляра блока**:

```js
onSetMod: {
    'js': {
        'inited': function() { /* ... */ } // конструктор экземпляра блока
    }
}
```


<a name="destruct"></a>
### Деструктор экземпляра блока ###

Моментом удаления блока является момент уничтожения всех ссылок на
JS-объект блока, после чего он может быть удален из памяти браузера
сборщиком мусора.

Триггер на удаление модификатора `js` (установку в пустое значение
`''`) выполняется перед удалением блока. Такой триггер можно считать
**деструктором экземпляра блока**.

```js
onSetMod: {
    'js': {
        '': function() { /* ... */ } // деструктор экземпляра блока
    }
}
```


<a name="init-wave"></a>
### Волны инициализации

Инициализация экземпляров блоков, присутствующих на странице, не
обязательно происходит одновременно. Блоки могут динамически добавляться в ходе
работы, инициализироваться по запросу или событию.
Инициализация очередной группы блоков называется **волной инициализации**.

Новая волна инициализации создается в следующих случаях:

* [Автоматическая инициализация блоков по событию `domReady`](#init-auto);
* [Инициализация блока по событию](#init-live) (ленивая инициализация);
* [Явный вызов инициализации блоков на указанном фрагменте DOM-дерева](#init-ajax).

<a name="init-auto"></a>
### Автоматическая инициализация

Фреймворк *i-bem.js* позволяет автоматически инициализировать блоки, с DOM-представлением в момент наступления DOM-события `domReady`. 

При автоматической инициализации в памяти браузера будут созданы JS-объекты для всех DOM-узлов, содержащих `i-bem` в атрибуте `class`. Инициализация выполняется функцией `init` модуля [i-bem__dom][].

Включить автоматическую инициализацию можно, указав блок `i-bem` с модификатором `init` в значении `auto` в файле зависимостей `.deps.js`.

**Пример файла** `.deps.js`:

```js
({
    shouldDeps: [
        {
            block: 'i-bem',
            elem: 'dom',
            mods: { 'init': 'auto' }
        }
    ]
})
```


При использовании в проекте блока [page](https://github.com/bem/bem-core/blob/v2/common.blocks/page/page.ru.md) не требуется самостоятельно включать автоматическую инициализацию.

**NB** Блоки для которых задана ленивая инициализация не будут инициализированы автоматически.

<a name="init-live"></a>
### Инициализация по событию (ленивая инициализация)

Если на странице размещено много экземпляров блоков, автоматическая инициализация
всех блоков в момент загрузки страницы нежелательна, так как она
увеличивает время загрузки и объем памяти, затрачиваемой браузером.

Удобнее инициализировать JS-объекты только в тот момент, когда их функциональность потребуется
пользователю: например, по клику на блоке. Такая инициализация называется **ленивой** или **live-инициализацией**.

Для описания условий ленивой инициализации в декларации зарезервировано статическое свойство `live`. Свойство `live` может иметь значения следующих типов:

* `Boolean`

 * `true` — экземпляры блоков данного класса будут инициализированы только при попытке получить соответствующий экземпляр (см. раздел [Взаимодействие блоков](#ibc)).

```js
modules.define('my-block', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name,
    {
        onSetMod: {
            'js': {
                'inited': function() { /* ... */ } // этот код будет выполняться
                                                   // при первом обращении к экземпляру блока
            }
        }
    },
    { live: 'true' } // статические методы и свойства
));

});
```


 * `false` — позволяет отменить ленивую инициализацию блоков, заданную на другом уровне переопределения.

* `Function`

Функция, выполняемая перед инициализацией **первого экземпляра** блока заданного класса. Если функция возвращает значение `false`, экземпляры блока будут инициализированы [автоматически](#init-auto). Например, перед инициализацией блока можно убедиться, что нужные ему данные доступны.

```js
modules.define('my-block', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name,
    {
        onSetMod: {
            'js': {
                'inited': function() { /* ... */ } // этот код будет выполняться
                                                   // при первом обращении к экземпляру блока
            }
        }
    },
    {
        live: function() {
            if(foo.bar) { return false } // проверяем наличие поля foo.bar в контексте
        }
    }
));

});
```


Чтобы инициализировать экземпляры блока по наступлению DOM- или БЭМ-событий, в теле функции следует выполнить подписку на [делегированные события](#delegated-events) или воспользоваться [хелпером](#init-live-helpers).

**Пример:** Экземпляры блока `my-block` будут инициализированы по DOM-событию `click` на DOM-узле блока. По каждому DOM-событию `click` будет вызываться метод экземпляра блока `_onClick`:

```js
modules.define('my-block', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name,
    {
        onSetMod: {
            'js': {
                'inited': function() { /* ... */ } // выполняется при первом DOM-событии 'click'
            }
        },

        _onClick: function(e) { /* ... */ } // выполняется при каждом DOM-событии 'click'
    },
    {
        live: function() {
            this.liveBindTo('click', function(e) {
                this._onClick(e); // в момент клика будет создан экземпляр блока и вызван его метод _onClick
            });
        }
    }
));

});
```


**NB** Свойство `live` относится к статическим методам класса блока. Поэтому даже если оно задано в декларации блока с определенным модификатором, `live` будет применено ко всем блокам данного класса вне зависимости от модификаторов.

<a name="init-live-helpers"></a>
### Хелперы для инициализации по событию

Для упрощения инициализации по событию в контексте экземпляра блока зарезервирован набор методов хелперов, позволяющий подписываться на следующие типы событий:

* DOM-события:
    * `liveBindTo([elemName], event, [callback])` - подписка с отложенной инициализацией на событие на DOM-узле блока или его элементах. Блок будет инициализирован по первому событию `event`. Функция-обработчик `callback` будет вызываться по событию `event` и после инициализации блока.
    * `liveUnbindFrom([elemName], event, [callback])` - удаление подписки с инициализацией по событию на DOM-узле блока или его элементах.
    * `liveInitOnEvent([elemName], event, callback)` - инициализация по событию на DOM-узле блока или его элементах.
* БЭМ-события:
    * `liveInitOnBlockEvent(event, blockName, callback)` - инициализация по БЭМ-событию экземпляра блока, размещенного на одном DOM-узле с текущим блоком.
    * `liveInitOnBlockInsideEvent(event, blockName, [callback])` - инициализация по БЭМ-событию экземпляра блока, вложенного в DOM-узле текущего блока.

Например, блок `menu` инициализируется по событию `click` вложенного в него блока `menu-item`.

```js
modules.define(
    'menu',
    ['i-bem__dom', 'menu-item'],
    function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name,
{ /* .. */ }, 
{
    live : function() {
        this.liveInitOnBlockInsideEvent('click', 'menu-item', function(e, data) {
                this._onItemClick(e.target, data);
            });
    }
}));

});
```


<a name="init-ajax"></a>
### Инициализация блоков на фрагменте DOM-дерева

Процедура инициализации JS-объектов может быть вызвана
явно для указанного фрагмента DOM-дерева. Часто такая необходимость
возникает при разработке AJAX-интерфейсов, когда нужно [динамически встроить](#dynamic) в страницу новые экземпляры блоков либо обновить существующие.

В `i-bem.js` следующие функции выполняют динамическую инициализацию блоков:

* Инициализация/уничтожение блоков на указанном фрагменте DOM-дерева (`init`);
* Добавление/замена фрагмента DOM-дерева с одновременной
инициализацией блоков на обновленном фрагменте (`update`, `replace`,
`append`, `prepend`, `before`, `after`).

<a name="destruct-dom"></a>
### Удаление блоков на фрагменте DOM-дерева

Как и процедура инициализации блоков, процедура удаления может быть вызвана явно для заданного фрагмента DOM-дерева. Например, при разработке AJAX-интерфейсов, для динамического удаления экземпляров блоков со страницы.

Явный вызов процедуры гарантирует корректное удаление:

* вложенных DOM-узлов;
* блоков, примешанных к другим блокам.

Для явного вызова процедуры удаления служит статический метод `BEMDOM.destruct`.

Метод принимает:

* `ctx` `{jQuery}` – корневой DOM-элемент. Удаляется со всем вложенными DOM-узлами.
* `excludeSelf` `Boolean` – не удалять корневой DOM-элемент если значение `true`. По умолчанию `false`.

Например, в блоке [popup_target_anchor](https://github.com/bem/bem-components/blob/v2/common.blocks/popup/_target/popup_target_anchor.js) библиотеки `bem-components` `destruct` используется приватным методом `_onPopupAnchorDestruct` для удаления текущего DOM-элемента при удалении якоря попапа:

```js
_onPopupAnchorDestruct : function() {
    BEMDOM.destruct(this.domElem);
}
```


<a name="init-bem"></a>
### Инициализация и удаление блоков без DOM-представления

Для создания JS-объектов блока без DOM-представления (не привязанного к HTML-элементу), служит метод `BEM.create`.

Метод принимает:

* `name` `{String|Object}` – имя блока;

Возвращает экземпляр блока указанного класса.

**Пример:** В момент инициализации экземпляра блока с DOM-представлением
`container` создается экземпляр блока без DOM-представления `router`. Экземпляр блока
`container` будет обращаться к созданному им экземпляру блока
`router` при вызове метода `onRequest`:

```js
modules.define('container', ['i-bem__dom', 'i-bem',] function(provide, BEM, BEMDOM) {

provide(BEMDOM.decl(this.name, {
    onSetMod: {
        'js': {
            'inited': function() {
                this._router = BEM.create('router'); // создание экземпляра блока router
            }
        }
    },

    onRequest: function() {
        this._router.route(/* ... */) // вызов метода экземпляра блока router
    }
}));

});
```


**Удаление** экземпляров блоков без DOM-представления не может быть
выполнено автоматически. Блоки без DOM-представления представляют собой обычные
JS-объекты и удаляются в момент удаления всех ссылок на объект блока.

**Пример:** При удалении экземпляра блока `container` удаляется созданный им в
процессе работы экземпляр блока без DOM-представления `router`.

```js
modules.define('container', ['i-bem', 'i-bem__dom'], function(provide, BEM, BEMDOM) {

provide(BEMDOM.decl(this.name, {
    onSetMod : {
        'js' : {
            '' : function() {
                delete this._router; // удаление экземпляра блока router
            }
        }
    }
}));

});
```


**Пример:** При использовании блока без DOM-представления реализованного в виде простого
[ym-модуля][ym] (без использования `i-bem`) нет необходимости создавать экземпляр блока.

```js
modules.define('container' ['i-bem__dom', 'router'], function(provide, BEMDOM, router) {

provide(BEMDOM.decl(this.name, {
    onRequest: function() {
        router.route(/* ... */); // вызов метода блока router
    }
}));

});
```


<a name="ibc"></a>
## Взаимодействие блоков

В рамках БЭМ-методологии блоки следует разрабатывать так, чтобы свести к минимуму зависимость состояний одних блоков от других. Однако на практике идеал полной независимости блоков недостижим.

Взаимодействие блоков может быть реализовано:

* с помощью подписки на [БЭМ-события](#bem-events) других экземпляров
блоков или подписки на [делегированные БЭМ-события](#bem-events-delegated);
* с помощью непосредственного вызова методов других экземпляров
блоков или статических методов класса другого блока.
* через проверку состояний одного блока из другого;
* через *каналы событий* (например с помощью элемента [channels](https://github.com/bem/bem-core/blob/v2/common.blocks/events/__channels/events__channels.ru.md) блока `events`)

**NB** Не используйте [DOM-события](#dom-events) для
организации взаимодействия между блоками. DOM-события предназначены
только для реализации внутренних процедур блока.

Для реализации взаимодействия блоков `i-bem.js` предоставляет API:

* [Поиск экземпляров блоков в DOM-дереве](#api-find);
* [Доступ к экземплярам блоков без DOM-представления](#api-nodom);
* [Доступ к классам блоков](#api-calss).

<a name="api-class"></a>
### Доступ к классам блоков

JS-компоненты, соответствующие всем блокам («классы» блоков), хранятся
в структуре данных, доступной через статическое свойство `BEMDOM.blocks`. 

Классы блоков, [без DOM-представления](#i-blocks), также размещены в этой структуре данных. Для доступа к таким блокам следует использовать конструкцию:

```js
BEM.blocks['name']
```


где `name` — имя блока.

Доступ к классам блоков необходим для:

* [делегирования БЭМ-событий](#bem-events-delegated);
* вызова статических методов класса.

**Пример:** Вызов статического метода `close` блока `popup` позволяет закрыть все попапы на странице:

```js
BEMDOM.decl('switcher', {
    onSetMod : {
        'popup' : {
            'disabled' : function() {
                BEMDOM.blocks['popup'].close();
            }
        }
    }
});
```


**NB** Статические свойства контекста `BEMDOM.blocks` и `DOM.blocks` содержат ссылки на одну и ту же структуру данных.

<a name="docs"></a>
## Что дальше?

Информацию о БЭМ-методологии, инструментарии и новостях в мире БЭМ смотрите на сайте [bem.info](https://ru.bem.info/).

Полную информацию обо всех методах API `i-bem.js` можно найти в JSDoc-комментариях к исходному коду:

* [i-bem][];
* [i-bem__dom][].

Обменяться опытом и задать вопрос опытным пользователям и разработчикам `i-bem.js` можно на [форуме](https://ru.bem.info/forum/).

БЭМ-сообщество в социальных сетях: 

* [Клуб в Я.ру](http://clubs.ya.ru/bem/);
* [Группа в Facebook](https://www.facebook.com/#!/groups/209713935765634/);
* [Twitter](https://twitter.com/bem_ru).

Прочитать о принципах работы `i-bem.js` в другом изложении, найти
образцы его применения и пошаговые инструкции на примере простых
проектов можно в статьях:

* [JavaScript по БЭМ: основные понятия](https://ru.bem.info/articles/bem-js-main-terms/);
* [Tutorial on JavaScript in BEM terms](https://github.com/varya/bem-js-tutorial);
* [Попробуй БЭМ на вкус!](http://habrahabr.ru/post/162385/);
* [БЭМ-приложение на Leaflet и API 2GIS](https://ru.bem.info/articles/firm-card-story/).


**NB** Обратите внимание, что в перечисленных статьях может
использоваться устаревший синтаксис, не соответствующий текущей версии
`i-bem.js`, включенной в `bem-core`.



[ym]: https://github.com/ym/modules

[bem-tools]: https://ru.bem.info/tools/bem/

[i-bem]: https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/i-bem.vanilla.js

[i-bem__dom]: https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/__dom/i-bem__dom.js
