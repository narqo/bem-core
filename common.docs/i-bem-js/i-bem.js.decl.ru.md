<a name="decl"></a>
## Декларация блока

JS-реализация блока описывает поведение определенного класса элементов веб-интерфейса. В конкретных интерфейсах каждый блок может быть представлен несколькими экземплярами. 
Экземпляр блока реализует функциональность своего класса и имеет собственное, независимое состояние.

В терминах парадигмы **объектно-ориентированного программирования**:

 * блок — класс;
 * экземпляр блока — экземпляр класса.

В соответствии с ООП, вся функциональность блока реализуется модульно в методах класса *(=блока)*.

Методы блока подразделяются на:

 * методы экземпляра блока;
 * статические методы.

Код блока в `i-bem.js` принято называть **декларацией**, чтобы подчеркнуть принятый
в БЭМ декларативный стиль программирования. 

Поведение блока программируется в декларативном стиле в виде утверждений: `набор условий` — `реакция блока`.

<a name="decl-syntax"></a>
### Синтаксис декларации

#### Блоки с DOM-представлением

##### Объявление нового блока без родителя

Чтобы задекларировать новый JS-блок **с DOM-представлением** (привязанный к HTML-элементу), нужно воспользоваться методом `decl` [ym][]-модуля `i-bem__dom`.

Метод `decl` принимает аргументы:

1. Описание блока `{String}` или `{Object}`.
2. Методы экземпляра блока — `{Object}`.
3. Статические методы — `{Object}`.

Объявленные методы будут применяться во всех экземплярах блока независимо от их состояний (модификаторов).

**Пример:** Декларация методов для блока `button`.

```js
modules.define('button', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name,
    {
        /* методы экземпляра */
    },
    {
        /* статические методы */
    })
);

});
```

Поле контекста `ym` `this.name`, передаваемое первым аргументом методу `BEMDOM.decl` содержит ссылку на имя блока, указанное первым аргументом `modules.define`.

<a name="bem-decl"></a>
#### Блоки без DOM-представления

Для декларации блоков без DOM-представления служит метод `decl` [ym][]-модуля `i-bem`.

Метод принимает те же параметры, что и метод `decl` модуля `i-bem__dom`:

```js
modules.define('my-block', ['i-bem'], function(provide, BEM) {

provide(BEM.decl(this.name,
    {
        /* методы экземпляра */
    },
    {
        /* статические методы */
    })
);

});
```


***

**NB** Оформлять инфраструктурный код в виде блока без DOM-представления удобно, если в нем планируется использовать API БЭМ-блоков (состояния, выражаемые модификаторами, БЭМ-события и
т. п.). Если использовать БЭМ-предметную область не планируется,
инфраструктурный код можно оформлять в виде [ym][]-модуля.

**Пример:**

```js
modules.define('router', function(provide) {

provide({
    route : function() { /* ... */ }
});

});
```


***

<a name="inher"></a>
### Наследование блока

Одна и та же функциональность может быть востребована в нескольких блоках проекта.
Например, разные блоки могут обращаться за данными к бэкенду, используя AJAX,
или совершать однотипные операции с DOM-деревом и т.д. Чтобы избежать ненужных повторов в коде, общую функциональность можно инкапсулировать в виде модулей, а затем добавлять к блокам.

Наследование позволяет повторно использовать функциональность блока, расширяя ее новой логикой.
В `i-bem.js` доступно несколько механизмов наследования. Выбор конкретного механизма зависит от специфики создаваемого блока.

<a name="inher-simple"></a>
#### Простое наследование

В случае простого наследования создаваемый блок объявляется как наследник существующего. Для этого нужно:

1. Указать базовый блок в зависимостях модульной системы.
2. Передать ссылку на базовый блок в специальном поле `baseBlock` декларации.

```js
modules.define('ablock', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name, {}));

});

modules.define('bblock', ['i-bem__dom', 'ablock'], function(provide, BEMDOM, ABlock) {

provide(BEMDOM.decl({ block : this.name, baseBlock : ABlock }));

});
```


Такой механизм позволяет использовать методы родительского блока внутри производного.
Для вызова базовой реализации одноименных методов родительского блока служит [специальное поле декларации](#decl-context) `this.__base`.

**NB** В `i-bem` можно создавать цепочки наследования – блок наследуется от другого,
который, в свою очередь, наследуется от третьего и т.д.

<a name="inher-over"></a>
#### Доопределение существующего блока

При наследовании можно сохранить основную функциональность базового блока.
Для этого можно **доопределить** базовый блок новым на уровне переопределения проекта.
Создаваемый в проекте блок реализует собственную логику, дополняющую или переопределяющую логику базового.
Такая схема наследования часто используется при работе с библиотечными блоками.

Чтобы доопределить существующий блок нужно создать новый блок с тем же именем.
Пересекающиеся методы и модификаторы будут переопределены в соответствие с декларацией нового блока.

```js
modules.define('ablock', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name, {})); // Объявляем базовый блок

});

modules.define('ablock', function(provide, ABlock) {

provide(ABlock.decl({})); // Доопределяем базовый блок

});
```


<a name="inher-over-modifier"></a>
##### Добавление модификатора к существующему блоку

В соответствии с БЭМ-методологией состояния блока должны описываться [модификаторами]([states]#modifiers).
Поэтому расширение функциональности блока часто предполагает реализацию поддержки новых модификаторов.

Для добавления модификатора необходимо передать методу `decl` доопределяемого блока:

* хэш с ключами `modName` и `modVal`. Значением для `modName` служит строка – имя модификатора. Значением `modVal` – строка со значением модификатора.
* хэш методов, которые будут доступны для блока с соответствующим модификатором. Пересекающиеся методы будут переопределены методами из хэша.

```js
modules.define('ablock', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name, {})); // Объявляем базовый блок

});

modules.define('ablock', function(provide, ABlock) {

provide(ABlock.decl({ modName : 'm1', modVal : 'v1' }, {})); // Доопределяем базовый блок с модификтором _m1_v1

});
```


**NB** [Cтатические методы][context] блока будут доступны всем его экземплярам *вне зависимости от значений модификаторов*.
Модификаторы это свойства экземпляра блока, а статические методы принадлежат классу
блока и не учитывают состояния модификаторов.

<a name="inher-mixins"></a>
#### Блоки-миксы

В `i-bem.js` для добавления востребованной функциональности к блокам, используется специальный
тип блоков – **блоки-миксы**. Главная особенность блоков-миксов состоит в том, что они не участвуют в цепочке наследования. Это позволяет примешивать реализованную в них функциональность к другим блокам без риска нарушить их [связи с родительскими блоками](#decl-context) (`this.__base`).

<a name="inher-mixins-declwithmix"></a>
##### Примешивание блока-микса

Чтобы примешать к блоку один или несколько блоков-миксов, необходимо в декларации блока присвоить значение опциональному полю `baseMix`. Значением служит массив строк – имен примешиваемых блоков-миксов:

```js
modules.define('my-block', ['i-bem__dom', 'foo', 'bar'], function(provide, BEMDOM) {

provide(BEMDOM.decl({ block : this.name, baseMix : ['foo', 'bar']},
    { /* методы экземпляра */ },
    { /* статические методы */ }
}));

});
```


<a name="inher-mixins-mixindecl"></a>
##### Декларация блока-микса

В качестве блоков-миксов можно использовать только блоки, созданные с помощью `declMix`.
Метод принимает декларацию блока в формате, аналогичном методу `decl`. 

Различие в том, что первым аргумент `declMix` – хэш вида `{ block : 'blockname' }`. Без указания модификаторов или примешиваемых блоков:

```js
modules.define('mymix', ['i-bem__dom'], function(provide, BEMDOM) {

provide(BEMDOM.declMix({ block : 'mymix' },
    { /* методы экземпляра */ },
    { /* статические методы */ }
}));

});
```


<a name="trigger-decl"></a>
#### Декларация триггеров

Триггеры, выполняемые при установке модификаторов, описываются в декларации блока. Для этого в хэше методов экземпляра блока зарезервированы свойства:

* `beforeSetMod` — триггеры, вызываемые до установки
**модификаторов блока**;
* `beforeElemSetMod` — триггеры, вызываемые до установки
**модификаторов элементов**;
* `onSetMod` — триггеры, вызываемые после установки
**модификаторов блока**;
* `onElemSetMod` — триггеры, вызываемые после установки
**модификаторов элементов** блока.

```js
modules.define('block-name', function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name,
    {
        /* методы экземпляра */
        beforeSetMod: { /* триггеры до установки модификаторов блока*/}
        beforeElemSetMod: { /* триггеры до установки модификаторов элементов*/}
        onSetMod: { /* триггеры после установки модификаторов блока */ }
        onElemSetMod: { /* триггеры после установки модификаторов элементов */ }
    },
    {
        /* статические методы */
    }
));

});
```


Значение свойств `beforeSetMod` и `onSetMod` — хэш, связывающий изменения модификаторов с триггерами. Триггер получает аргументами:

* `modName` – имя модификатора;
* `modVal` – выставляемое значение модификатора;
* `prevModVal` – предыдущее значение модификатора. Для `beforeSetMod` это текущее значение модификатора, которое будет заменено на `modVal`, если триггер вернет `true`.

```js
{
    'mod1': function(modName, modVal, prevModVal) { /* ... */ }, // установка mod1 в любое значение
    'mod2': {
        'val1': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val1
        'val2': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val2
        '': function(modName, modVal, prevModVal) { /* ... */ } // триггер на удаление модификатора mod2
    'mod3': {
        'true': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку простого модификатора mod3
        '': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на удаление простого модификатора mod3
    },
    '*': function(modName, modVal, prevModVal) { /* ... */ } // триггер на установку любого модификатора в любое значение
}
```


Для триггера на установку любого модификатора блока в любое значение
существует сокращенная форма записи:

```js
beforeSetMod: function(modName, modVal, prevModVal) { /* ... */ }
onSetMod: function(modName, modVal, prevModVal) { /* ... */ }
```


Для свойств `beforeElemSetMod` и `onElemSetMod` в хэш значений
добавляется дополнительный уровень вложенности — **имя элемента**. В этих
свойствах описываются триггеры на установку модификаторов элементов.
Триггер получает аргументами:

* `elem` — имя элемента;
* `modName` – имя модификатора;
* `modVal` – выставляемое значение модификатора;
* `prevModVal` – предыдущее значение модификатора. Для `beforeSetMod` это текущее значение модификатора, которое будет заменено на `modVal`, если триггер вернет `true`.

```js
{
    'elem1': {
        'mod1': function(elem, modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod1 элемента elem 1 в любое значение
        'mod2': {
            'val1': function(elem, modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 элемента elem1 в значение val1
            'val2': function(elem, modName, modVal, prevModVal) { /* ... */ } // триггер на установку mod2 элемента elem1 в значение val2
            }
        },
    'elem2': function(elem, modName, modVal, prevModVal) { /* ... */ } // триггер на установку любого модификатора элемента elem2 в любое значение
}
```


Сокращенная запись для триггера на установку любого модификатора элемента `elem1` в любое значение:

```js
beforeElemSetMod: { 'elem1': function(elem, modName, modVal, prevModVal) { /* ... */ } }
onElemSetMod: { 'elem1': function(elem, modName, modVal, prevModVal) { /* ... */ } }
```


<a name="decl-context"></a>
### Специальные поля декларации

В декларации зарезервированы специальные поля:

* `this.__self`: предоставляет доступ к статическим методам блока из методов его экземпляра. Для статических методов не имеет смысла и не определено.

**Пример:** Вызов статического метода `staticMethod` в методе `onEvent` экземпляра блока `my-block`.

```js
BEMDOM.decl('my-block', {
    onEvent: function() {
        this.__self.staticMethod(); // вызов статического метода
        this.doMore();
    },
    {
        staticMethod: function() { /* ... */ }; // определение статического метода
    }
});
```


* `this.__base`: вызывает реализацию одноименного метода в базовом классе, от которого наследуется данный (`super call`). Определен в методах экземпляра и статических методах блока.

**Пример:** вызов базовой реализации метода `_onClick` базового класса `button`.

```js
BEMDOM.decl({ block: 'my-button', baseBlock: 'button' }, {
    _onClick: function() {
        this.__base();
        this.doMore();
    }
);
```


***

**NB** Так как блоки-миксы не участвуют в цепочке наследования, внутри них поле `__base` недоступно.

***


[ym]: https://github.com/ymaps/modules

[bem-tools]: https://ru.bem.info/tools/bem/

[i-bem]: https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/i-bem.vanilla.js

[i-bem__dom]: https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/__dom/i-bem__dom.js

[html]: ./i-bem.js.html-binding.ru.md

[decl]: ./i-bem.js.decl.ru.md

[dom]: ./i-bem.js.dom.ru.md

[context]: ./i-bem.js.context.ru.md

[states]: ./i-bem.js.states.ru.md

[events]: ./i-bem.js.states.ru.md

[init]: ./i-bem.js.init.ru.md

[interact]: ./i-bem.js.interact.ru.md

[extras]: ./i-bem.js.extras.ru.md
